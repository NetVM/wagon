package modules

import (
	"crypto/rand"
	"encoding/binary"
	"errors"
	"fmt"
	"reflect"
	"time"

	"github.com/go-interpreter/wagon/exec"
	"github.com/go-interpreter/wagon/wasm"
)

var (
	// ErrGoMemKindMismatch is Returned when importing a module generated by Go and the 'mem' is not of kind "ExternalMemory"
	ErrGoMemKindMismatch = errors.New("expected import 'mem' to be of kind wasm.ExternalMemory")
)

// Go is the Go WASM runtime module (emulates wasm_exec.js shipped with Go)
type Go struct {
	*wasm.Module

	timeOrigin time.Time
}

func stub(name string) func(proc *exec.Process, sp int32) {
	return func(proc *exec.Process, sp int32) {
		fmt.Println("called", name, "with val", sp)
	}
}

const (
	goExportIndexDebug = iota
	goExportIndexRuntimeWasmExit
	goExportIndexRuntimeWasmWrite
	goExportIndexRuntimeNanotime
	goExportIndexRuntimeWalltime
	goExportIndexRuntimeScheduleCallback
	goExportIndexRuntimeClearScheduledCallback
	goExportIndexRuntimeGetRandomData
	goExportIndexSyscallJSStringVal
	goExportIndexSyscallJSValueGet
	goExportIndexSyscallJSValueCall
	goExportIndexSyscallJSValueNew
	goExportIndexSyscallJSValuePrepareString
	goExportIndexSyscallJSValueLoadString

	goExportIndexLength
)

// NewGo creates a new Go WASM runtime module
func NewGo() (*Go, error) {
	g := &Go{
		Module:     wasm.NewModule(),
		timeOrigin: time.Now(),
	}

	g.Types.Entries = make([]wasm.FunctionSig, goExportIndexLength)
	g.FunctionIndexSpace = make([]wasm.Function, goExportIndexLength)
	g.Export.Entries = map[string]wasm.ExportEntry{}

	g.mapFunc("debug", goExportIndexDebug, stub("debug"), []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("runtime.wasmExit", goExportIndexRuntimeWasmExit, g.exportExit, []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("runtime.wasmWrite", goExportIndexRuntimeWasmWrite, g.exportWasmWrite, []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("runtime.nanotime", goExportIndexRuntimeNanotime, g.exportNanotime, []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("runtime.walltime", goExportIndexRuntimeWalltime, stub("runtime.walltime"), []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("runtime.scheduleCallback", goExportIndexRuntimeScheduleCallback, stub("runtime.scheduleCallback"), []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("runtime.clearScheduledCallback", goExportIndexRuntimeClearScheduledCallback, stub("runtime.clearScheduledCallback"), []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("runtime.getRandomData", goExportIndexRuntimeGetRandomData, g.exportGetRandomData, []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("syscall/js.stringVal", goExportIndexSyscallJSStringVal, stub("syscall/js.stringVal"), []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("syscall/js.valueGet", goExportIndexSyscallJSValueGet, g.exportValueGet, []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("syscall/js.valueCall", goExportIndexSyscallJSValueCall, stub("syscall/js.valueCall"), []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("syscall/js.valueNew", goExportIndexSyscallJSValueNew, stub("syscall/js.valueNew"), []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("syscall/js.valuePrepareString", goExportIndexSyscallJSValuePrepareString, stub("syscall/js.valuePrepareString"), []wasm.ValueType{wasm.ValueTypeI32}, nil)
	g.mapFunc("syscall/js.valueLoadString", goExportIndexSyscallJSValueLoadString, stub("syscall/js.valueLoadString"), []wasm.ValueType{wasm.ValueTypeI32}, nil)

	return g, nil
}

// BufferAt is anything that can return a buffer at an offset and length
type BufferAt interface {
	BufferAt(offset, length int64) ([]byte, error)
}

func (g *Go) setInt32(ba BufferAt, addr int32, v int32) {
	buf, err := ba.BufferAt(int64(addr), 8)
	if err != nil {
		panic(err)
	}
	binary.LittleEndian.PutUint32(buf, uint32(v))
}

func (g *Go) setInt64(ba BufferAt, addr int32, v int64) {
	buf, err := ba.BufferAt(int64(addr), 8)
	if err != nil {
		panic(err)
	}
	binary.LittleEndian.PutUint64(buf, uint64(v))
}

func (g *Go) getInt64(ba BufferAt, addr int32) int64 {
	buf, err := ba.BufferAt(int64(addr), 8)
	if err != nil {
		panic(err)
	}
	return int64(binary.LittleEndian.Uint64(buf))
}

func (g *Go) getInt32(ba BufferAt, addr int32) int32 {
	buf, err := ba.BufferAt(int64(addr), 8)
	if err != nil {
		panic(err)
	}
	return int32(binary.LittleEndian.Uint32(buf))
}

func (g *Go) loadSlice(ba BufferAt, sp int32) ([]byte, error) {
	offset := g.getInt64(ba, sp)
	length := g.getInt64(ba, sp+8)

	return ba.BufferAt(offset, length)
}

func (g *Go) loadString(ba BufferAt, sp int32) (string, error) {
	buf, err := g.loadSlice(ba, sp)
	if err != nil {
		return "", err
	}
	return string(buf), nil
}

func (g *Go) exportValueLoadString(proc *exec.Process, sp int32) {

}

func (g *Go) exportValueNew(proc *exec.Process, sp int32) {

}

func (g *Go) exportValueGet(proc *exec.Process, sp int32) {
	s, err := g.loadString(proc, sp+16)
	if err != nil {
		panic(err)
	}

	fmt.Println("Get", s)
}

func (g *Go) exportWalltime(proc *exec.Process, sp int32) {
	n := time.Now()

	nsec := n.UnixNano()
	secs := nsec / 1e9
	nsec = nsec - (secs * 1e9)
	g.setInt64(proc, sp+8, secs)
	g.setInt32(proc, sp+16, int32(nsec))
}

func (g *Go) exportNanotime(proc *exec.Process, sp int32) {
	g.setInt64(proc, sp+8, time.Since(g.timeOrigin).Nanoseconds())
}

func (g *Go) exportGetRandomData(proc *exec.Process, sp int32) {
	s, err := g.loadSlice(proc, sp)
	if err != nil {
		panic(err)
	}
	rand.Read(s)
}

func (g *Go) exportWasmWrite(proc *exec.Process, sp int32) {
	p := g.getInt64(proc, sp+16)
	n := g.getInt32(proc, sp+24)

	buf, err := proc.BufferAt(p, int64(n))
	if err != nil {
		panic(err)
	}

	fmt.Print(string(buf))
}

func (g *Go) exportExit(proc *exec.Process, sp int32) {
	proc.Terminate()
}

func (g *Go) mapFunc(name string, i int, f interface{}, params []wasm.ValueType, returns []wasm.ValueType) {
	g.Types.Entries[i] = wasm.FunctionSig{
		Form:        0,
		ParamTypes:  params,
		ReturnTypes: returns,
	}

	g.FunctionIndexSpace[i] = wasm.Function{
		Sig:  &g.Types.Entries[i],
		Host: reflect.ValueOf(f),
		Body: &wasm.FunctionBody{},
	}

	g.Export.Entries[name] = wasm.ExportEntry{
		FieldStr: name,
		Kind:     wasm.ExternalFunction,
		Index:    uint32(i),
	}
}
